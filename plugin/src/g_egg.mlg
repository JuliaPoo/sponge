DECLARE PLUGIN "egg_plugin"

{

open Ltac_plugin

open Construction_game

(* This one is necessary, to avoid message about missing wit_string *)
open Stdarg

}

VERNAC COMMAND EXTEND ShowTypeConstruction CLASSIFIED AS QUERY
| [ "Test3_1" ] ->
  { let env = Global.env () in
    let sigma = Evd.from_env env in
    let sigma, s = Evd.new_sort_variable Evd.univ_rigid sigma in
    let new_type_2 = EConstr.mkSort s in
    let sigma, _ =
      Typing.type_of (Global.env()) (Evd.from_env (Global.env())) new_type_2 in
    Feedback.msg_notice
      (Printer.pr_econstr_env env sigma new_type_2) }
END

VERNAC COMMAND EXTEND ShowOneConstruction CLASSIFIED AS QUERY
| [ "Test3_2" ] -> { example_sort_app_lambda () }
END

TACTIC EXTEND egg_simpl_goal
| [ "egg_simpl_goal" int(ffn_limit) ] ->
  { Test_tactic.egg_simpl_goal ffn_limit }
END

TACTIC EXTEND egg_cvc5
| [ "egg_cvc5" ] ->
  { Test_tactic.egg_cvc5 () }
END

TACTIC EXTEND egg_search_evars
| [ "egg_search_evars" int(ffn_limit)] ->
  { Test_tactic.egg_search_evars ffn_limit }
END

TACTIC EXTEND inspect
| [ "inspect" open_constr(c) ] ->
  { Test_tactic.inspect c }
END

(* More advanced examples, where automatic proof happens but
   no tactic is being called explicitly.  The first one uses
   type classes. *)
VERNAC COMMAND EXTEND TriggerClasses CLASSIFIED AS QUERY
| [ "Test3_3" int(n) ] -> { example_classes n }
END

(* The second one uses canonical structures. *)
VERNAC COMMAND EXTEND TriggerCanonical CLASSIFIED AS QUERY
| [ "Test3_4" int(n) ] -> { example_canonical n }
END
